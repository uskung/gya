\pagenumbering{Roman}
\refstepcounter{chapter}
\chapter*{Appendix}
\appendix
\section*{A - Härledning av Euler-Lagrange ekvationen (\ref{eq:euler_lagrange_equation})} \label{appendix:euler_lagrange_equation}

Denna härledningen är huvudsakligen baserat på \cite[s. 222-223]{book:classical_mechanics:Morin2007}. Givet att funktionen $x_0(t)$ beskriver den väg av ett objekt, med startpunkterna $x(t_1) = x_1$ och $x(t_2) = x_2$, som ger ett stationärt\footnote{Kan alltså vara ett lokalt minimum, maximum eller terrasspunkt av $S$. Däremot är detta oftast ett minimum, därför det oftast benämns som \emph{principen om \emph{minsta} verkan.}} värde av objektets verkan $S$, då gäller att:
\begin{equation}
    \frac{d}{dt}\left( \frac{\partial \Lagr}{\partial \dot{q_{i}}} \right) - \frac{\partial \Lagr}{\partial q_{i}} = 0. 
    \label{eq:euler_lagrange_equation_appendix}
\end{equation}

\textit{Bevis:} Eftersom $x_0(t)$ är den funktion som ger ett stationärt värde av $S$, så kommer en funktion som är väldigt nära $x_0(t)$ ger i princip exakt samma verkan. Betrakta därmed funktionen:
\begin{equation}
    x_a(t) = x_0(t) + a\beta(t),
\end{equation}
där $a$ är ett tal och $\beta(t)$ uppfyller $\beta(t_1) = \beta(t_2) = 0$ så att ändpunkterna för $x_a(t)$ och $x_0(t)$ är detsamma. 

\newpage
\section*{B - Kod för simulering av dubbelpendeln} \label{appendix:code}

\begin{lstlisting}[language=Python, caption=Kod för Runge-Kutta metoden]
import matplotlib.pyplot as plt 
import numpy as np
from matplotlib.animation import FuncAnimation

plt.rc('font', size = 11, family='serif')
plt.rc('text', usetex=True)
plt.rc('font', serif='Computer Modern')

the1 = float(eval(input("Ange startvinkeln for theta_1: ")))
the2 = float(eval(input("Ange startvinkeln for theta_2: ")))
ome1 = 0
ome2 = 0
h = 0.00005
t_tot= float(input("Hur manga sekunder vill du simulera pendeln? "))
t0 = 0

m_1 = 1
m_2 = 1
l_1 = 1
l_2 = 1
g = 9.82

the1_list = [the1]
the2_list = [the2]
x1pos = []
y1pos = []
x2pos = []
y2pos = []

state = np.array([the1, ome1, the2, ome2])

def derivative(state):
    the1, ome1, the2, ome2 = state
    dtheta = the1 - the2
    alpha = (m_1 + m_2)*l_1
    beta = m_2*l_2*np.cos(dtheta)
    gamma = m_2*l_1*np.cos(dtheta)
    delta = m_2*l_2
    epsilon = -1*m_2*l_2 * ome2**2 * np.sin(dtheta) - (m_1 + m_2)*g*np.sin(the1)
    zeta = m_2*l_2 * ome1**2 * np.sin(dtheta) - m_2*g*np.sin(the2)

    domega1 = (delta*epsilon - beta*zeta)/(alpha*delta - beta*gamma) # calculates new domega1
    domega2 = (alpha*zeta - gamma*epsilon)/(alpha*delta - beta*gamma) # calculates new domega2

    return np.array([ome1, domega1, ome2, domega2])

while t0 < t_tot + h:
    #calculate coordinates of pendulum
    ## calculates coordinates of mass 1
    x1 = l_1*np.sin(state[0])
    x1pos.append(x1)
    y1 = -1 * l_1 * np.cos(state[0])
    y1pos.append(y1)

    ## calculates coordinates of mass 2
    x2 = l_1*np.sin(state[0]) + l_2*np.sin(state[2])
    x2pos.append(x2)
    y2 = -1 * l_1*np.cos(state[0]) - l_2*np.cos(state[2])
    y2pos.append(y2)

    K1 = derivative(state)
    K2 = derivative(state + h/2 * K1)
    K3 = derivative(state + h/2 * K2)
    K4 = derivative(state + h * K3)

    state = state + h/6 * (K1 + 2*K2 + 2*K3 + K4)

    the1_list.append(state[0])
    the2_list.append(state[2])

    t0 += h

ax = plt.gca()
ax.set_xlim([-2.5,2.5])
ax.set_ylim([-2.5,2.5])

plt.grid()

plt.plot(x2pos, y2pos, color='red', ls=(0,(1,10)), label='Path of mass 2')
plt.plot([0,x1pos[-1]], [0,y1pos[-1]], color='blue')
plt.plot([x1pos[-1], x2pos[-1]], [y1pos[-1], y2pos[-1]], color='blue')
plt.plot(x1pos[-1], y1pos[-1], 'o', markersize=15, color='red')
plt.plot(x2pos[-1], y2pos[-1], 'o', markersize=15, color='red')

plt.xlabel(' $x$-position [m]')
plt.ylabel('$y$-position [m]')

ax = plt.gca()
ax.set_xlim([-2.5, 2.5])
ax.set_ylim([-2.5, 2.5])
ax.set_aspect('equal', adjustable='box')

plt.savefig(f'runge-kutta_plots/runge-kutta_plot_the1={the1}_the2={the2}_at_{t_tot}s.png', dpi=300)

plt.show()
\end{lstlisting}